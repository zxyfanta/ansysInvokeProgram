# 激光毁伤仿真系统测试策略设计

## 1. 测试策略概述

### 1.1 测试金字塔

```
        /\
       /  \
      /E2E \     系统测试 (10%)
     /______\    - 端到端测试
    /        \   - 用户验收测试
   /Integration\ 集成测试 (20%)
  /__________\  - 模块集成测试
 /            \ - ANSYS集成测试
/  Unit Tests  \ 单元测试 (70%)
/______________\ - 函数级测试
                 - 类级测试
```

### 1.2 测试分类

| 测试类型 | 占比 | 执行频率 | 执行时间 | 目标 |
|---------|------|----------|----------|------|
| 单元测试 | 70% | 每次提交 | < 5分钟 | 验证单个函数/类的正确性 |
| 集成测试 | 20% | 每日构建 | < 30分钟 | 验证模块间交互 |
| 系统测试 | 10% | 发布前 | < 2小时 | 验证完整功能流程 |

## 2. 单元测试策略

### 2.1 测试覆盖范围

#### 2.1.1 核心模块测试
```python
# tests/unit/test_laser_damage_simulator.py
import pytest
import numpy as np
from unittest.mock import Mock, patch, MagicMock

from laser_damage.laser_damage.simulator import LaserDamageSimulator
from laser_damage.core.data_models import LaserConfiguration, MaterialConfiguration
from laser_damage.core.exceptions import SimulationError, ConfigurationError


class TestLaserDamageSimulator:
    """激光毁伤仿真器单元测试"""
    
    def setup_method(self):
        """测试前置设置"""
        self.simulator = LaserDamageSimulator()
        self.valid_config = {
            "model_path": "tests/data/test_plate.step",
            "laser_parameters": {
                "power": 1000.0,
                "wavelength": 1064.0,
                "beam_diameter": 5.0,
                "pulse_duration": 0.001
            },
            "material_parameters": {
                "name": "aluminum_6061",
                "thermal_conductivity": 167.0,
                "specific_heat": 896.0,
                "density": 2700.0,
                "melting_point": 933.0,
                "absorption_coefficient": 0.1
            }
        }
    
    def test_validate_configuration_valid_params(self):
        """测试有效参数验证"""
        result = self.simulator.validate_configuration(self.valid_config)
        assert result is True
        assert self.simulator.laser_config is not None
        assert self.simulator.material_config is not None
    
    def test_validate_configuration_missing_laser_params(self):
        """测试缺少激光参数的情况"""
        invalid_config = self.valid_config.copy()
        del invalid_config["laser_parameters"]
        
        with pytest.raises(ConfigurationError, match="缺少激光参数配置"):
            self.simulator.validate_configuration(invalid_config)
    
    def test_validate_configuration_invalid_laser_power(self):
        """测试无效激光功率"""
        invalid_config = self.valid_config.copy()
        invalid_config["laser_parameters"]["power"] = -100.0
        
        with pytest.raises(ConfigurationError):
            self.simulator.validate_configuration(invalid_config)
    
    @patch('laser_damage.utils.ansys_utils.AnsysConnector.test_connection')
    def test_prepare_simulation_success(self, mock_connection):
        """测试仿真准备成功"""
        mock_connection.return_value = True
        self.simulator.validate_configuration(self.valid_config)
        
        result = self.simulator.prepare_simulation()
        assert result is True
        mock_connection.assert_called_once()
    
    @patch('laser_damage.utils.ansys_utils.AnsysConnector.test_connection')
    def test_prepare_simulation_ansys_failure(self, mock_connection):
        """测试ANSYS连接失败"""
        mock_connection.return_value = False
        self.simulator.validate_configuration(self.valid_config)
        
        result = self.simulator.prepare_simulation()
        assert result is False
    
    @patch('laser_damage.laser_damage.simulator.LaserDamageSimulator.execute_simulation')
    @patch('laser_damage.laser_damage.simulator.LaserDamageSimulator.prepare_simulation')
    @patch('laser_damage.laser_damage.simulator.LaserDamageSimulator.validate_configuration')
    def test_run_simulation_complete_workflow(self, mock_validate, mock_prepare, mock_execute):
        """测试完整仿真工作流程"""
        # 设置mock返回值
        mock_validate.return_value = True
        mock_prepare.return_value = True
        mock_result = Mock()
        mock_result.max_temperature = 1200.0
        mock_result.max_stress = 250e6
        mock_execute.return_value = mock_result
        
        result = self.simulator.run_simulation(self.valid_config)
        
        assert result is not None
        assert result.max_temperature == 1200.0
        mock_validate.assert_called_once_with(self.valid_config)
        mock_prepare.assert_called_once()
        mock_execute.assert_called_once()


class TestLaserConfiguration:
    """激光配置类单元测试"""
    
    def test_valid_configuration(self):
        """测试有效配置"""
        config = LaserConfiguration(
            power=1000.0,
            wavelength=1064.0,
            beam_diameter=5.0,
            pulse_duration=0.001
        )
        assert config.validate() is True
    
    def test_invalid_power(self):
        """测试无效功率"""
        with pytest.raises(ValueError, match="激光功率必须大于0"):
            config = LaserConfiguration(
                power=-100.0,
                wavelength=1064.0,
                beam_diameter=5.0
            )
            config.validate()
    
    def test_invalid_wavelength(self):
        """测试无效波长"""
        with pytest.raises(ValueError, match="波长必须大于0"):
            config = LaserConfiguration(
                power=1000.0,
                wavelength=-500.0,
                beam_diameter=5.0
            )
            config.validate()


class TestMaterialConfiguration:
    """材料配置类单元测试"""
    
    def test_valid_material_config(self):
        """测试有效材料配置"""
        config = MaterialConfiguration(
            name="aluminum_6061",
            thermal_conductivity=167.0,
            specific_heat=896.0,
            density=2700.0,
            melting_point=933.0,
            absorption_coefficient=0.1
        )
        assert config.validate() is True
    
    def test_invalid_thermal_conductivity(self):
        """测试无效热导率"""
        with pytest.raises(ValueError, match="热导率必须大于0"):
            config = MaterialConfiguration(
                name="test_material",
                thermal_conductivity=-10.0,
                specific_heat=896.0,
                density=2700.0,
                melting_point=933.0,
                absorption_coefficient=0.1
            )
            config.validate()
```

#### 2.1.2 工具类测试
```python
# tests/unit/test_ansys_utils.py
import pytest
from unittest.mock import Mock, patch, MagicMock
import os

from laser_damage.utils.ansys_utils import AnsysConnector
from laser_damage.core.exceptions import AnsysIntegrationError


class TestAnsysConnector:
    """ANSYS连接器单元测试"""
    
    def setup_method(self):
        """测试前置设置"""
        self.connector = AnsysConnector()
    
    @patch.dict(os.environ, {'ANSYS_ROOT': '/opt/ansys_inc/v211'})
    @patch('pathlib.Path.exists')
    def test_init_with_valid_environment(self, mock_exists):
        """测试有效环境变量初始化"""
        mock_exists.return_value = True
        connector = AnsysConnector()
        assert connector.ansys_root == '/opt/ansys_inc/v211'
    
    @patch('laser_damage.utils.ansys_utils.ANSYS_AVAILABLE', False)
    def test_test_connection_no_pymapdl(self):
        """测试PyMAPDL未安装的情况"""
        result = self.connector.test_connection()
        assert result is False
    
    @patch('laser_damage.utils.ansys_utils.ANSYS_AVAILABLE', True)
    @patch('laser_damage.utils.ansys_utils.launch_mapdl')
    def test_test_connection_success(self, mock_launch):
        """测试连接成功"""
        mock_mapdl = Mock()
        mock_mapdl.version = "2021 R1"
        mock_launch.return_value = mock_mapdl
        
        result = self.connector.test_connection()
        assert result is True
        mock_mapdl.exit.assert_called_once()
    
    @patch('laser_damage.utils.ansys_utils.ANSYS_AVAILABLE', True)
    @patch('laser_damage.utils.ansys_utils.launch_mapdl')
    def test_test_connection_failure(self, mock_launch):
        """测试连接失败"""
        mock_launch.side_effect = Exception("Connection failed")
        
        result = self.connector.test_connection()
        assert result is False
```

### 2.2 测试数据管理

#### 2.2.1 测试数据集
```python
# tests/conftest.py
import pytest
import numpy as np
from pathlib import Path

@pytest.fixture
def sample_temperature_field():
    """样本温度场数据"""
    return np.random.uniform(293, 1500, (100, 100))

@pytest.fixture
def sample_stress_field():
    """样本应力场数据"""
    return np.random.uniform(0, 500e6, (100, 100))

@pytest.fixture
def test_model_path():
    """测试模型路径"""
    return Path("tests/data/models/simple_plate.step")

@pytest.fixture
def laser_config_dict():
    """激光配置字典"""
    return {
        "power": 1000.0,
        "wavelength": 1064.0,
        "beam_diameter": 5.0,
        "pulse_duration": 0.001
    }

@pytest.fixture
def material_config_dict():
    """材料配置字典"""
    return {
        "name": "aluminum_6061",
        "thermal_conductivity": 167.0,
        "specific_heat": 896.0,
        "density": 2700.0,
        "melting_point": 933.0,
        "absorption_coefficient": 0.1
    }
```

## 3. 集成测试策略

### 3.1 模块集成测试

#### 3.1.1 仿真工作流程测试
```python
# tests/integration/test_simulation_workflow.py
import pytest
from pathlib import Path

from laser_damage import LaserDamageSimulator, PostDamageAnalyzer
from laser_damage.core.data_models import SimulationStatus


class TestSimulationWorkflow:
    """仿真工作流程集成测试"""
    
    @pytest.mark.integration
    @pytest.mark.slow
    def test_complete_laser_damage_workflow(self, laser_config_dict, material_config_dict):
        """测试完整激光毁伤工作流程"""
        # 准备配置
        config = {
            "model_path": "tests/data/models/test_plate.step",
            "laser_parameters": laser_config_dict,
            "material_parameters": material_config_dict
        }
        
        # 1. 激光毁伤仿真
        simulator = LaserDamageSimulator()
        result = simulator.run_simulation(config)
        
        # 验证仿真结果
        assert result is not None
        assert result.status == SimulationStatus.COMPLETED
        assert result.max_temperature > 293.15  # 高于环境温度
        assert result.temperature_field is not None
        assert result.stress_field is not None
        
        # 2. 后效分析
        post_analyzer = PostDamageAnalyzer()
        post_result = post_analyzer.analyze_post_damage(result)
        
        # 验证后效分析结果
        assert post_result is not None
        assert post_result.aerodynamic_impact is not None
    
    @pytest.mark.integration
    def test_data_pipeline_integration(self):
        """测试数据处理管道集成"""
        from laser_damage.data_analysis.data_extractor import DataExtractor
        from laser_damage.data_analysis.data_processor import DataProcessor
        
        # 模拟结果文件
        mock_result_files = [
            "tests/data/results/thermal_result.rst",
            "tests/data/results/structural_result.rst"
        ]
        
        # 数据提取
        extractor = DataExtractor()
        raw_data = extractor.extract_simulation_data(mock_result_files)
        assert raw_data is not None
        
        # 数据处理
        processor = DataProcessor()
        processed_data = processor.process_data(raw_data)
        assert processed_data is not None
        assert processed_data.temperature_field is not None
```

### 3.2 ANSYS集成测试

#### 3.2.1 ANSYS连接测试
```python
# tests/integration/test_ansys_integration.py
import pytest
import os
from pathlib import Path

from laser_damage.utils.ansys_utils import AnsysConnector


class TestAnsysIntegration:
    """ANSYS集成测试"""
    
    @pytest.mark.ansys
    @pytest.mark.slow
    def test_ansys_connection_real(self):
        """测试真实ANSYS连接"""
        if not os.environ.get('ANSYS_ROOT'):
            pytest.skip("ANSYS_ROOT环境变量未设置")
        
        connector = AnsysConnector()
        result = connector.test_connection()
        assert result is True
    
    @pytest.mark.ansys
    @pytest.mark.slow
    def test_mapdl_launch_and_close(self):
        """测试MAPDL启动和关闭"""
        if not os.environ.get('ANSYS_ROOT'):
            pytest.skip("ANSYS_ROOT环境变量未设置")
        
        connector = AnsysConnector()
        
        # 启动MAPDL
        mapdl = connector.launch_mapdl(
            working_dir="./test_ansys_work",
            memory_limit="4GB",
            cpu_cores=2
        )
        
        assert mapdl is not None
        assert mapdl.version is not None
        
        # 简单测试
        mapdl.prep7()
        mapdl.et(1, 'SOLID186')
        mapdl.block(0, 1, 0, 1, 0, 1)
        
        # 关闭MAPDL
        connector.close_mapdl()
    
    @pytest.mark.ansys
    def test_geometry_loading(self):
        """测试几何模型加载"""
        if not os.environ.get('ANSYS_ROOT'):
            pytest.skip("ANSYS_ROOT环境变量未设置")
        
        connector = AnsysConnector()
        mapdl = connector.launch_mapdl()
        
        # 测试STEP文件加载
        test_step_file = "tests/data/models/simple_cube.step"
        if Path(test_step_file).exists():
            result = connector.load_geometry(test_step_file)
            assert result is True
        
        connector.close_mapdl()
```

## 4. 系统测试策略

### 4.1 端到端测试

#### 4.1.1 用户场景测试
```python
# tests/system/test_end_to_end.py
import pytest
import time
from pathlib import Path

from laser_damage import LaserDamageSimulator
from laser_damage.gui.main_window import LaserSimulationApp


class TestEndToEndScenarios:
    """端到端测试场景"""
    
    @pytest.mark.e2e
    @pytest.mark.slow
    def test_typical_user_workflow(self):
        """测试典型用户工作流程"""
        # 模拟用户操作流程
        app = LaserSimulationApp()
        
        # 1. 加载模型
        model_path = "tests/data/models/aircraft_wing.step"
        if not Path(model_path).exists():
            pytest.skip(f"测试模型不存在: {model_path}")
        
        success = app.load_model(model_path)
        assert success is True
        
        # 2. 配置参数
        laser_params = {
            'power': 2000,
            'wavelength': 1064,
            'pulse_duration': 0.001
        }
        app.configure_laser_parameters(laser_params)
        
        # 3. 运行仿真
        simulation_id = app.start_simulation()
        assert simulation_id is not None
        
        # 等待仿真完成（最多30分钟）
        completed = app.wait_for_completion(simulation_id, timeout=1800)
        assert completed is True
        
        # 4. 生成报告
        report = app.generate_report(simulation_id)
        assert report is not None
        assert Path(report.file_path).exists()
        
        # 5. 验证结果
        assert report.damage_assessment.thermal_damage_area > 0
    
    @pytest.mark.performance
    def test_performance_benchmarks(self):
        """性能基准测试"""
        start_time = time.time()
        
        # 运行标准测试用例
        simulator = LaserDamageSimulator()
        config = self._get_standard_test_config()
        
        result = simulator.run_simulation(config)
        
        execution_time = time.time() - start_time
        
        # 性能要求验证
        assert execution_time < 1800  # 30分钟内完成
        assert result.max_temperature > 0
        
        # 内存使用检查
        import psutil
        process = psutil.Process()
        memory_usage_gb = process.memory_info().rss / 1024 / 1024 / 1024
        assert memory_usage_gb < 8.0  # 不超过8GB
    
    def _get_standard_test_config(self):
        """获取标准测试配置"""
        return {
            "model_path": "tests/data/models/standard_test.step",
            "laser_parameters": {
                "power": 1000.0,
                "wavelength": 1064.0,
                "beam_diameter": 5.0
            },
            "material_parameters": {
                "name": "aluminum_6061",
                "thermal_conductivity": 167.0,
                "specific_heat": 896.0,
                "density": 2700.0,
                "melting_point": 933.0,
                "absorption_coefficient": 0.1
            }
        }
```

### 4.2 性能测试

#### 4.2.1 负载测试
```python
# tests/system/test_performance.py
import pytest
import time
import concurrent.futures
from pathlib import Path

from laser_damage import LaserDamageSimulator


class TestPerformance:
    """性能测试"""
    
    @pytest.mark.performance
    @pytest.mark.slow
    def test_concurrent_simulations(self):
        """测试并发仿真性能"""
        num_concurrent = 3
        config = self._get_lightweight_config()
        
        def run_single_simulation():
            simulator = LaserDamageSimulator()
            return simulator.run_simulation(config)
        
        start_time = time.time()
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_concurrent) as executor:
            futures = [executor.submit(run_single_simulation) for _ in range(num_concurrent)]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]
        
        total_time = time.time() - start_time
        
        # 验证所有仿真都成功完成
        assert len(results) == num_concurrent
        for result in results:
            assert result is not None
            assert result.max_temperature > 0
        
        # 性能要求：并发执行不应超过单个执行时间的2倍
        single_execution_estimate = 300  # 5分钟估计
        assert total_time < single_execution_estimate * 2
    
    @pytest.mark.performance
    def test_memory_usage_stability(self):
        """测试内存使用稳定性"""
        import psutil
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss
        
        # 运行多次仿真
        config = self._get_lightweight_config()
        for i in range(5):
            simulator = LaserDamageSimulator()
            result = simulator.run_simulation(config)
            assert result is not None
            
            # 强制垃圾回收
            import gc
            gc.collect()
            
            current_memory = process.memory_info().rss
            memory_growth = (current_memory - initial_memory) / 1024 / 1024  # MB
            
            # 内存增长不应超过500MB
            assert memory_growth < 500, f"内存增长过多: {memory_growth:.2f}MB"
    
    def _get_lightweight_config(self):
        """获取轻量级测试配置"""
        return {
            "model_path": "tests/data/models/simple_cube.step",
            "laser_parameters": {
                "power": 500.0,
                "wavelength": 1064.0,
                "beam_diameter": 2.0
            },
            "material_parameters": {
                "name": "aluminum",
                "thermal_conductivity": 167.0,
                "specific_heat": 896.0,
                "density": 2700.0,
                "melting_point": 933.0,
                "absorption_coefficient": 0.1
            }
        }
```

## 5. 测试执行与报告

### 5.1 测试执行配置
```ini
# pytest.ini
[tool:pytest]
minversion = 6.0
addopts = 
    -ra
    --strict-markers
    --strict-config
    --cov=src/laser_damage
    --cov-report=term-missing
    --cov-report=html:htmlcov
    --cov-report=xml
    --junit-xml=test-results.xml

testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

markers =
    unit: 单元测试
    integration: 集成测试
    system: 系统测试
    e2e: 端到端测试
    performance: 性能测试
    slow: 慢速测试
    ansys: 需要ANSYS环境的测试
    gui: GUI相关测试

filterwarnings =
    ignore::UserWarning
    ignore::DeprecationWarning
```

### 5.2 测试报告生成
```bash
# 运行不同类型的测试
pytest tests/unit/                    # 单元测试
pytest tests/integration/ -m "not ansys"  # 集成测试（不包括ANSYS）
pytest tests/system/ -m "not slow"   # 系统测试（快速）

# 生成详细报告
pytest --cov=src/laser_damage --cov-report=html --html=report.html --self-contained-html

# 性能测试
pytest -m performance --benchmark-only
```

---

**文档版本**: v1.0  
**创建日期**: 2024-01-01  
**适用范围**: 激光毁伤仿真系统测试团队
